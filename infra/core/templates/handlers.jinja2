"""
{{ service.description }}
MCP Protocol Handlers - Auto-generated from tool_config.yaml
Generated at: {{ generated_at }}
Source config: {{ config_path }}

DO NOT EDIT THIS FILE DIRECTLY
Modify tool_config.yaml and regenerate using:
python scripts/generate_handlers.py --config {{ config_path }}
"""

import json
from typing import Any, Dict, List, Optional
from mcp.types import Tool, TextContent, Prompt, PromptArgument, PromptMessage

from infra.core.logger import get_logger
from infra.core.tool_registry import ToolRegistry, ToolConfig
{% if service.import_from %}
from .{{ service.import_from }} import {{ service.name }}
{% else %}
from .tools import {{ service.name }}
{% endif %}
from .schemas import (
{%- for tool in tools %}
    {%- if tool.request_class and tool.request_class != 'dict' %}
    {{ tool.request_class }},
    {%- endif %}
    {%- if tool.response_class and tool.response_class not in ['None', 'dict'] %}
    {{ tool.response_class }},
    {%- endif %}
{%- endfor %}
)
{%- if prompts %}
from .prompts import get_prompt
{%- endif %}

logger = get_logger(__name__)


class {{ service.handler_class }}:
    """{{ service.description }} MCP Protocol Handlers"""

    def __init__(self):
        """Initialize handlers with tools instance and registry"""
        {% if service.import_from %}
        self.{{ service.import_from }} = {{ service.name }}()
        {% else %}
        self.tools = {{ service.name }}()
        {% endif %}
        self.registry = ToolRegistry()
        self._register_tools()
        logger.info("âœ… {{ service.handler_class }} initialized with {{ tools|length }} tools")

    def _register_tools(self):
        """Register all tools in the registry"""
        {% for tool in tools %}
        # {{ tool.name }}: {{ tool.description[:60] }}...
        self.registry.register(
            ToolConfig(
                name="{{ tool.name }}",
                description="{{ tool.description | replace('"', '\\"') }}",
                {%- if tool.request_class == 'dict' %}
                request_class=dict,
                {%- else %}
                request_class={{ tool.request_class }},
                {%- endif %}
                {%- if tool.response_class == 'dict' %}
                response_class=dict,
                {%- elif tool.response_class and tool.response_class != 'None' %}
                response_class={{ tool.response_class }},
                {%- else %}
                response_class=None,
                {%- endif %}
                {%- if service.import_from %}
                method=self.{{ service.import_from }}.{{ tool.method_name }},
                {%- else %}
                method=self.tools.{{ tool.method_name }},
                {%- endif %}
                auth_required={{ 'True' if tool.auth_required else 'False' }},
                {%- if tool.auth_field %}
                auth_field="{{ tool.auth_field }}",
                {%- else %}
                auth_field=None,
                {%- endif %}
                {%- if 'input_schema' in tool %}
                input_schema={{ tool.input_schema | tojson }},
                {%- elif 'parameters' in tool %}
                parameters={{ tool.parameters | tojson | replace('true', 'True') | replace('false', 'False') }},
                {%- else %}
                parameters=[],
                {%- endif %}
            )
        )
        {% endfor %}

    # ========================================================================
    # MCP Protocol: list_tools
    # ========================================================================

    async def handle_list_tools(self) -> List[Tool]:
        """List available MCP tools"""
        logger.info("ğŸ”§ [MCP Handler] list_tools() called")
        return self.registry.list_tools()

    # ========================================================================
    # MCP Protocol: call_tool
    # ========================================================================

    async def handle_call_tool(
        self,
        name: str,
        arguments: Dict[str, Any],
        authenticated_user_id: Optional[str] = None
    ) -> List[TextContent]:
        """Handle MCP tool calls"""
        logger.info(f"ğŸ”¨ [MCP Handler] call_tool({name}) with args: {arguments}")

        try:
            {%- if has_auth_tools %}
            # ì¸ì¦ ê¸°ë°˜ user_id ê°•ì œ ì ìš© (ê²€ìƒ‰ ê³„ì—´ íˆ´ì—ë§Œ í•´ë‹¹)
            auth_tools = [{{ auth_tool_names | join(', ') }}]
            if name in auth_tools:
                from infra.core.auth_helpers import get_authenticated_user_id

                # ë„êµ¬ë³„ ì¸ì¦ í•„ë“œ ë§¤í•‘
                auth_fields = {
                {%- for tool in tools if tool.auth_required %}
                    "{{ tool.name }}": "{{ tool.auth_field }}",
                {%- endfor %}
                }

                auth_field = auth_fields.get(name, "user_id")
                provided_user = arguments.get(auth_field)

                # ê³µí†µ í—¬í¼ ì ìš©
                resolved_user = get_authenticated_user_id(
                    {"user_id": provided_user} if provided_user else {},
                    authenticated_user_id,
                )

                # ë³´ì•ˆ ê²€ì¦ ë¡œê¹…
                if authenticated_user_id and provided_user and provided_user != authenticated_user_id:
                    logger.warning(
                        f"âš ï¸ ë³´ì•ˆ: ì¸ì¦ëœ user_id({authenticated_user_id})ì™€ íŒŒë¼ë¯¸í„° {auth_field}({provided_user})ê°€ ë‹¤ë¦„. ì¸ì¦ëœ user_id ì‚¬ìš©."
                    )

                if resolved_user:
                    arguments[auth_field] = resolved_user
            {%- endif %}

            # Registryë¥¼ í†µí•œ ë„êµ¬ ì‹¤í–‰
            response = await self.registry.call_tool(
                name=name,
                arguments=arguments,
                authenticated_user_id=authenticated_user_id
            )

            # ì‘ë‹µ í¬ë§·íŒ…
            if hasattr(response, 'message'):
                return [TextContent(type="text", text=response.message)]
            elif hasattr(response, 'model_dump_json'):
                return [TextContent(type="text", text=response.model_dump_json(indent=2))]
            else:
                return [TextContent(type="text", text=str(response))]

        except ValueError as e:
            error_msg = str(e)
            logger.error(error_msg)
            return [
                TextContent(
                    type="text",
                    text=json.dumps(
                        {"success": False, "message": error_msg}, indent=2
                    ),
                )
            ]

        except Exception as e:
            logger.error(f"âŒ Tool ì‹¤í–‰ ì˜¤ë¥˜: {name}, {str(e)}", exc_info=True)
            error_response = {"success": False, "message": f"ì˜¤ë¥˜ ë°œìƒ: {str(e)}"}
            return [
                TextContent(type="text", text=json.dumps(error_response, indent=2))
            ]

    # ========================================================================
    # Helper: Convert to dict (for HTTP responses)
    # ========================================================================

    async def call_tool_as_dict(
        self,
        name: str,
        arguments: Dict[str, Any],
        authenticated_user_id: Optional[str] = None
    ) -> Dict[str, Any]:
        """
        HTTP APIìš© í—¬í¼: call_tool ê²°ê³¼ë¥¼ dictë¡œ ë°˜í™˜

        MCPëŠ” TextContentë¥¼ ë°˜í™˜í•˜ì§€ë§Œ,
        HTTP APIëŠ” JSON dictë¥¼ ë°˜í™˜í•´ì•¼ í•˜ë¯€ë¡œ ë³€í™˜ í—¬í¼ ì œê³µ
        """
        try:
            response = await self.registry.call_tool(
                name=name,
                arguments=arguments,
                authenticated_user_id=authenticated_user_id
            )

            if hasattr(response, 'model_dump'):
                return response.model_dump()
            elif hasattr(response, '__dict__'):
                return response.__dict__
            else:
                return {"result": str(response)}

        except Exception as e:
            logger.error(f"âŒ Tool ì‹¤í–‰ ì˜¤ë¥˜: {name}, {str(e)}", exc_info=True)
            raise

    {%- if prompts %}

    # ========================================================================
    # MCP Protocol: list_prompts
    # ========================================================================

    async def handle_list_prompts(self) -> List[Prompt]:
        """List available MCP prompts"""
        logger.info("ğŸ“‹ [MCP Handler] list_prompts() called")

        return [
            {%- for prompt in prompts %}
            Prompt(
                name="{{ prompt.name }}",
                description="{{ prompt.description }}",
                arguments=[
                    {%- for arg in prompt.arguments %}
                    PromptArgument(
                        name="{{ arg.name }}",
                        description="{{ arg.description }}",
                        required={{ arg.required | lower }}
                    ),
                    {%- endfor %}
                ]
            ),
            {%- endfor %}
        ]

    # ========================================================================
    # MCP Protocol: get_prompt
    # ========================================================================

    async def handle_get_prompt(
        self, name: str, arguments: Dict[str, Any]
    ) -> PromptMessage:
        """Get specific prompt content"""
        logger.info(f"ğŸ“ [MCP Handler] get_prompt({name}) called with args: {arguments}")

        try:
            return await get_prompt(name, arguments)
        except Exception as e:
            logger.error(f"âŒ Prompt ì‹¤í–‰ ì˜¤ë¥˜: {name}, {str(e)}", exc_info=True)
            raise
    {%- endif %}
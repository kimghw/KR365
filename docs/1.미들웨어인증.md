# Claude.ai 최초 서버 접속 시 DCR 미들웨어 인증 과정

Claude.ai에서 MCP 서버에 최초 접속할 때의 전체 인증 흐름과 각 모듈 간 호출-응답 관계를 다음과 같이 설명드리겠습니다.

## 1단계: MCP Discovery (인증 제외)

Claude.ai가 서버 정보를 확인하기 위해 Discovery 엔드포인트를 호출합니다. 이 단계에서는 인증이 필요하지 않습니다.

**요청 흐름:**
```
Claude.ai → GET /.well-known/mcp.json → unified_mcp_discovery_handler()
```

**DCR 미들웨어 처리:**
auth_middleware.py의 verify_bearer_token_middleware 함수가 요청을 가로채지만, 경로에 "/.well-known/"이 포함되어 있으므로 인증을 건너뛰고 None을 반환합니다. logs_db에는 "skipped" 상태로 기록됩니다.

**응답:**
서버는 OAuth 엔드포인트 정보와 사용 가능한 MCP 서비스 목록을 JSON 형태로 반환합니다. 여기에는 /oauth/register, /oauth/authorize, /oauth/token 엔드포인트 정보가 포함됩니다.

## 2단계: OAuth 동적 클라이언트 등록 (DCR)

Claude.ai가 서버에 클라이언트를 등록합니다.

**요청 흐름:**
```
Claude.ai → POST /oauth/register → dcr_register_handler()
                                  → DCRService.register_client()
```

**DCR 미들웨어 처리:**
/oauth/ 경로로 시작하는 요청이므로 인증이 제외되며, 미들웨어는 None을 반환합니다.

**DCRService.register_client() 내부 처리:**

먼저 요청 헤더에서 mcp-session-id 또는 traceparent를 추출하여 세션 ID를 식별합니다. 그 다음 dcr_clients 테이블을 조회하여 세션 재사용 여부를 확인합니다.

동일한 mcp_session_id를 가진 클라이언트가 있으면 기존 client_id와 client_secret을 재사용합니다. 없으면 새로운 dcr_client_id를 생성하고 dcr_clients 테이블에 저장합니다. 이때 azure_object_id는 NULL로 저장됩니다(로그인 전 상태).

**응답:**
RFC 7591 형식의 클라이언트 등록 응답이 반환됩니다. 여기에는 client_id, client_secret, redirect_uris가 포함됩니다.

**Comments**
- 동일한 mcp_session_id를 가진 클라이언트가 있으면 기존 client_id와 client_secret을 재사용합니다. 없으면 새로운 dcr_client_id를 생성하고 dcr_clients 테이블에 저장합니다. 이때 azure_object_id는 NULL로 저장됩니다 -- 여기서 azure_object_id를 NULL로 저장되는 로직을 삭제해줘. 


## 3단계: OAuth 인증 시작

Claude.ai가 사용자 인증을 위해 authorization 엔드포인트를 호출합니다.

**요청 흐름:**
```
Claude.ai → GET /oauth/authorize → oauth_authorize_handler()
                                  → DCRService.get_client()
                                  → DCRService.create_authorization_code()
```

**DCR 미들웨어 처리:**
/oauth/ 경로이므로 인증이 제외됩니다.

**oauth_authorize_handler() 내부 처리:**

요청 파라미터에서 client_id, redirect_uri, scope, state, code_challenge를 추출합니다. DCRService.get_client()를 호출하여 클라이언트 정보를 조회합니다.

클라이언트가 존재하고 이미 활성화된 Bearer 토큰이 있는 경우, 새로운 authorization_code를 생성하여 즉시 Claude.ai로 리다이렉트합니다(Azure AD 단계 건너뛰기).

활성화된 토큰이 없으면 DCRService.create_authorization_code()를 호출하여 임시 authorization_code를 생성하고 dcr_tokens 테이블에 저장합니다. 이 코드는 10분 후 만료됩니다.

**Azure AD 리다이렉트:**
사용자를 Azure AD 로그인 페이지로 리다이렉트합니다. state 파라미터에는 내부 auth_code와 원본 state가 "auth_code:state" 형식으로 인코딩됩니다.

**Comments**
- 

## 4단계: Azure AD 콜백 처리

사용자가 Azure AD에서 인증을 완료하면 서버의 콜백 엔드포인트로 리다이렉트됩니다.

**요청 흐름:**
```
Azure AD → GET /oauth/azure_callback → oauth_azure_callback_handler()
                                      → Azure Token Exchange (httpx)
                                      → DCRService.save_azure_tokens_and_sync()
                                      → DCRService.update_client_user()
```

**DCR 미들웨어 처리:**
/oauth/ 경로이므로 인증이 제외됩니다.

**oauth_azure_callback_handler() 내부 처리:**

state 파라미터를 디코딩하여 auth_code와 원본 state를 추출합니다. dcr_tokens 테이블에서 auth_code로 dcr_client_id와 metadata를 조회합니다.

Azure AD의 authorization code를 사용하여 토큰 교환 API를 호출합니다. httpx 라이브러리를 사용하여 POST 요청을 보내며, 성공 시 Azure access_token과 refresh_token을 받습니다.

Microsoft Graph API를 호출하여 사용자 정보를 조회합니다. 여기서 user_email, user_name, azure_object_id를 얻습니다.

DCRService.is_user_allowed()를 호출하여 사용자 이메일의 도메인이 허용된 도메인 목록에 있는지 확인합니다. 허용되지 않은 사용자는 403 응답을 받습니다.

DCRService.save_azure_tokens_and_sync()를 호출하여 Azure 토큰을 dcr_azure_users 테이블에 저장하고, 동시에 graphapi.db의 accounts 테이블과 동기화합니다. 토큰은 AccountCryptoHelpers를 사용하여 암호화됩니다.

DCRService.update_client_user()를 호출하여 dcr_clients 테이블의 azure_object_id와 user_email을 업데이트합니다. 이제 클라이언트가 특정 사용자와 연결됩니다.

dcr_tokens 테이블에서 auth_code의 azure_object_id를 업데이트합니다.

**Claude.ai로 리다이렉트:**
원본 redirect_uri에 authorization_code와 state를 포함하여 Claude.ai로 리다이렉트합니다.

**Comments**
state 파라미터로, dcr_tokens 테이블에서 dcr_client_id를 얻고  Microsoft Graph API 호출해서 azure)object_id를 얻고 난 후에, DCRService.update_client_user()를 호출하여 특정 사용자와 연결됩니다. 근데 현재 구조에서  registery 를 하지 않고 Oauth 를 호출해서 로그인을 하는 경우가 있는데, 이 경우 claude.ai나 chatgpt 가 사용하는 dcr_client_id 와 mcp 서버의 dcr_client_id가 매칭이 되지 않아 에러가 발생함. Claude.ai로 리다이렉트 하기 전에 object_id 랑 dcr_client_name 이 같은 dcr_client_id가 존재 한다면 새로운 값으로 관련된 dcr_azure_users와 dcr_clients, 그리고 토큰값을 갱신한다. 

## 5단계: DCR Bearer 토큰 발급

Claude.ai가 authorization_code를 사용하여 최종 access_token을 요청합니다.

**요청 흐름:**
```
Claude.ai → POST /oauth/token → oauth_token_handler()
                               → DCRService.verify_authorization_code()
                               → DCRService.get_azure_tokens_by_object_id()
                               → DCRService.verify_client_credentials()
```

**DCR 미들웨어 처리:**
/oauth/ 경로이므로 인증이 제외됩니다.

**oauth_token_handler() 내부 처리:**

form 데이터에서 grant_type, client_id, client_secret, code, code_verifier를 추출합니다. HTTP Basic Auth도 지원합니다.

grant_type이 "authorization_code"인 경우, DCRService.verify_authorization_code()를 호출하여 코드를 검증합니다. PKCE가 사용된 경우 code_verifier를 검증합니다. 검증 후 dcr_tokens에서 해당 코드의 상태를 'expired'로 변경합니다.

검증 성공 시 반환된 azure_object_id로 DCRService.get_azure_tokens_by_object_id()를 호출하여 dcr_azure_users 테이블에서 Azure 토큰을 조회합니다.

기존에 동일한 client_id와 azure_object_id를 가진 활성화된 Bearer 토큰이 있는지 확인합니다. 있으면 해당 토큰을 재사용하고, 없으면 새로운 DCR Bearer 토큰을 생성합니다.

새 토큰은 secrets.token_urlsafe()로 생성되며, AccountCryptoHelpers로 암호화되어 dcr_tokens 테이블에 저장됩니다. refresh_token도 함께 생성되어 저장됩니다(30일 유효).

**응답:**
RFC 6749 형식의 토큰 응답이 반환됩니다. 여기에는 access_token, token_type, expires_in, refresh_token, scope가 포함됩니다.

## 6단계: MCP 요청 시 DCR 미들웨어 인증

이후 Claude.ai가 MCP 서버에 요청을 보낼 때마다 DCR 미들웨어가 동작합니다.

**요청 흐름:**
```
Claude.ai → POST /teams/v1/chat/completions
          → DCR Middleware: verify_bearer_token_middleware()
          → DCRService.verify_bearer_token()
          → get_user_id_from_azure_object_id()
          → MCP Server Handler
```

**DCR 미들웨어 상세 처리:**

OAuth2Middleware의 dispatch 메서드가 모든 요청을 가로챕니다. 요청 경로와 메서드를 확인하여 인증 제외 여부를 판단합니다.

verify_bearer_token_middleware 함수가 호출됩니다. Authorization 헤더에서 "Bearer " 접두사를 제거하고 토큰을 추출합니다.

DCRService.verify_bearer_token()가 호출됩니다. 이 함수는 dcr_tokens 테이블에서 활성화된 Bearer 토큰을 모두 조회한 후, 각 토큰을 복호화하여 요청의 토큰과 비교합니다. secrets.compare_digest()를 사용하여 안전하게 비교합니다.

토큰이 일치하면 dcr_client_id와 azure_object_id를 반환합니다.

get_user_id_from_azure_object_id() 함수가 호출되어 azure_object_id로 dcr_azure_users 테이블에서 user_email을 조회하고, 이를 사용하여 graphapi.db의 accounts 테이블에서 user_id를 찾습니다.

검증이 성공하면 request.state에 dcr_client_id, azure_object_id, user_id를 저장합니다. logs_db.log_dcr_middleware()를 호출하여 인증 성공을 기록합니다.

미들웨어는 None을 반환하여 요청을 다음 핸들러로 전달합니다.

**MCP 서버 처리:**
각 MCP 서버(teams, mail-query, onenote 등)는 request.state에서 user_id를 읽어 사용자별 데이터를 처리합니다.

**인증 실패 시:**
토큰이 없거나 유효하지 않으면 DCR 미들웨어가 JSONResponse를 반환하여 요청을 차단합니다. 상태 코드는 401이며, WWW-Authenticate 헤더가 포함됩니다. logs_db에는 "failed" 상태로 기록됩니다.

## 모듈 간 데이터베이스 상호작용

DCR 인증 과정에서 여러 데이터베이스 테이블이 사용됩니다.

**dcr.db:**
dcr_azure_app 테이블은 Azure 앱 정보를 저장합니다. dcr_azure_users 테이블은 사용자별 Azure 토큰을 저장합니다. dcr_clients 테이블은 DCR 클라이언트 정보를 저장합니다. dcr_tokens 테이블은 DCR 토큰을 저장합니다.

**graphapi.db:**
accounts 테이블은 DCRService.save_azure_tokens_and_sync()에 의해 자동으로 동기화됩니다. 이를 통해 기존 MCP 서버들이 동일한 인증 정보를 사용할 수 있습니다.

**logs.db:**
dcr_middleware_logs 테이블은 모든 미들웨어 인증 시도를 기록합니다.

## 환경변수 우선순위

DCR 설정 로드 시 환경변수가 데이터베이스보다 우선순위가 높습니다. DCR_OAUTH_REDIRECT_URI 환경변수가 설정되어 있으면 dcr_azure_app 테이블의 redirect_uri보다 우선하여 사용됩니다. 이는 azure_config.py의 load_azure_config 함수에서 처리됩니다.

이러한 전체 흐름을 통해 Claude.ai는 단일 OAuth 인증으로 모든 MCP 서비스에 접근할 수 있으며, DCR 미들웨어가 모든 요청에 대해 중앙 집중식 인증을 제공합니다.